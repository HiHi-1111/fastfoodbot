import numpy as np
import cv2
from text_finder_orc import get_current_phase
from order_processor import (
    split_order_items,
    identify_ingredient,
    detect_fries_request,
    detect_drink_request,
    parse_ingredient_order,
)
import time
from mouse import move_mouse, click_left
from win32_utils import get_screen_size, get_cursor_pos, capture_screen
import json
import math
import os
import pytesseract
import threading
import tkinter as tk
from PIL import Image, ImageTk
import signal
import sys

class FastFoodBot:
    def __init__(self):
        self.current_state = 1
        self.items = ["cheese", "lettuce", "tomato", "onion", "patty", "veg"]
        self.step_duraction_alpha = 0.01
        self.screen_width, self.screen_height = get_screen_size()
        self.items_in_order = {item: 0 for item in self.items}
        self.button_aliases = {
            'veg': 'veg_patty',
            'cola': 'drink',
            'lemon_lime': 'juice',
            'shake': 'milkshake'
        }
        self.extra_items = {'fries_icon': 0, 'drinks_icon': 0}
        self.order_area = self._load_order_area()
        self.order_started = False
        self.running = True  # Flag to control the loop
        self.target_frame_interval = 1.0 / 60.0
        self.target_fps = int(round(1.0 / self.target_frame_interval))
        self.display_fps = self.target_fps
        self.capture_fps = self.target_fps
        self._display_frame_times = []
        self._capture_frame_times = []
        self._fps_lock = threading.Lock()
        self._phase2_templates = None
        self._phase2_size_templates = None

        self.ui_profile = self._load_ui_profile()
        self.roi_bubble = self.ui_profile.get('ROI_BUBBLE', {'x': 0.165, 'y': 0.17, 'w': 0.67, 'h': 0.23})
        self.roi_sides_grid = self.ui_profile.get('ROI_SIDES_GRID', {'x': 0.79, 'y': 0.32, 'w': 0.10, 'h': 0.33})
        self.roi_size_col = self.ui_profile.get('ROI_SIZE_COL', {'x': 0.905, 'y': 0.28, 'w': 0.05, 'h': 0.33})
        self.roi_confirm = self.ui_profile.get('ROI_CONFIRM', {'x': 0.965, 'y': 0.58, 'w': 0.03, 'h': 0.08})
        self.roi_drinks_grid = self.ui_profile.get('ROI_DRINKS_GRID', {'x': 0.79, 'y': 0.32, 'w': 0.10, 'h': 0.33})
        self.roi_drink_tab = self.ui_profile.get('ROI_DRINK_TAB', {'x': 0.97, 'y': 0.46, 'w': 0.02, 'h': 0.08})
        self.type_conf_threshold = 0.82
        self.size_conf_threshold = 0.80
        self.fries_type_rows = ['fries_classic', 'fries_thick', 'onion_rings']
        self.drink_type_rows = ['cola', 'lemon_lime', 'shake']
        self._phase2_attempt_started = None
        self._phase3_attempt_started = None
        self._phase2_nav_done = False
        self._phase2_nav_last_click = 0.0
        self.phase2_menu_visible = False
        self.phase2_menu_retry_used = False
        self.phase2_menu_deadline = 0.0
        self._phase3_nav_done = False
        self._phase3_nav_last_click = 0.0
        self._last_repeat_request = 0.0
        self._bottom_prompt_text = ""

        # GUI setup
        self.gui_root = tk.Tk()
        self.gui_root.title("Fast Food Bot State")
        self.gui_root.protocol("WM_DELETE_WINDOW", self.shutdown)  # Handle window close
        self.state_label = tk.Label(self.gui_root, text=f"Current State: {self.current_state}", font=("Arial", 16))
        self.state_label.pack(padx=20, pady=10)

        # Add ingredients display
        self.ingredients_label = tk.Label(self.gui_root, text="Current Order: None", font=("Arial", 12), justify=tk.LEFT)
        self.ingredients_label.pack(padx=20, pady=5)

        self.phase2_info_label = tk.Label(self.gui_root, text="Sides: waiting", font=("Arial", 11), justify=tk.LEFT)
        self.phase2_info_label.pack(padx=20, pady=(0, 5), anchor="w")
        self.phase3_info_label = tk.Label(self.gui_root, text="Drinks: waiting", font=("Arial", 11), justify=tk.LEFT)
        self.phase3_info_label.pack(padx=20, pady=(0, 5), anchor="w")

        self.fps_label = tk.Label(self.gui_root, text=f"FPS: display {self.target_fps} | capture {self.target_fps}", font=("Arial", 10), anchor="w")
        self.fps_label.pack(padx=20, pady=(0,5), anchor="w")

        # Add screenshot display
        self.screenshot_label = tk.Label(self.gui_root)
        self.screenshot_label.pack(padx=20, pady=10)
        self.tk_screenshot = None  # To keep a reference

        # Add "ingredients to identify" section
        self.ingredients_frame = tk.Frame(self.gui_root)
        self.ingredients_frame.pack(padx=20, pady=10)
        self.ingredients_heading = tk.Label(self.ingredients_frame, text="Ingredients to Identify:", font=("Arial", 12, "bold"))
        self.ingredients_heading.grid(row=0, column=0, sticky="w")
        self.ingredient_images = []  # To keep references to PhotoImages

    def shutdown(self):
        """Gracefully shutdown the bot"""
        print("\nShutting down Fast Food Bot...")
        self.running = False
        if self.gui_root:
            self.gui_root.quit()
            self.gui_root.destroy()

    def update_gui_state(self):
        self.state_label.config(text=f"Current State: {self.current_state}")

    def update_gui_ingredients(self):
        """Update the ingredients display in the GUI"""
        if not self.order_started:
            ingredients_text = "Current Order: None"
        else:
            # Show only ingredients with count > 0
            active_items = []
            for item, count in self.items_in_order.items():
                if count > 0:
                    display_name = self.button_aliases.get(item, item)
                    active_items.append(f"{display_name}: {count}")
            if active_items:
                ingredients_text = "Current Order:\n" + "\n".join(active_items)
            else:
                ingredients_text = "Current Order: Processing..."
        
        self.ingredients_label.config(text=ingredients_text)

    def _update_fps_meter(self, bucket, mode):
        with self._fps_lock:
            now = time.perf_counter()
            bucket.append(now)
            cutoff = now - 0.75
            while bucket and bucket[0] < cutoff:
                bucket.pop(0)
            if len(bucket) > 1:
                duration = bucket[-1] - bucket[0]
                fps = len(bucket) / duration if duration > 1e-6 else self.target_fps
            elif len(bucket) == 1:
                fps = self.target_fps
            else:
                fps = 0.0
            fps_int = max(0, int(round(fps)))
            is_target = abs(fps_int - self.target_fps) <= 1
            if mode == 'display':
                self.display_fps = fps_int
            else:
                self.capture_fps = fps_int
            status = 'true' if is_target else 'false'
            self.fps_label.config(text=f"FPS: display {self.display_fps} | capture {self.capture_fps} | target={status}")

    def update_gui_screenshot(self, image):
        # Convert PIL Image to Tkinter PhotoImage and display
        if isinstance(image, np.ndarray):
            image = cv2.cvtColor(np.array(image), cv2.COLOR_BGR2RGB)
            image = Image.fromarray(image)
        elif not isinstance(image, Image.Image):
            image = Image.fromarray(np.array(image))

        # Resize for GUI display
        display_width = 400
        aspect = image.height / image.width
        display_height = int(display_width * aspect)
        image = image.resize((display_width, display_height), Image.LANCZOS)

        self.tk_screenshot = ImageTk.PhotoImage(image)
        self.screenshot_label.config(image=self.tk_screenshot)

    def update_ingredients_to_identify(self, item_images):
        # Clear previous images
        for widget in self.ingredients_frame.winfo_children():
            if widget != self.ingredients_heading:
                widget.destroy()
        self.ingredient_images.clear()

        # Display new images in a row
        for i, img in enumerate(item_images):
            # Convert to PIL Image if needed
            if isinstance(img, np.ndarray):
                img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
                pil_img = Image.fromarray(img)
            elif not isinstance(img, Image.Image):
                pil_img = Image.fromarray(np.array(img))
            else:
                pil_img = img

            # Resize for display
            display_size = (80, 80)
            pil_img = pil_img.resize(display_size, Image.LANCZOS)
            tk_img = ImageTk.PhotoImage(pil_img)
            self.ingredient_images.append(tk_img)  # Keep reference

            label = tk.Label(self.ingredients_frame, image=tk_img)
            label.grid(row=1, column=i, padx=5, pady=2)

    def get_quantity_from_bottom(self, image):
        if image is None or getattr(image, 'size', 0) == 0:
            return 1
        h = image.shape[0]
        start_row = max(int(h * 0.75), 0)
        crop = image[start_row:, :]
        if crop.size == 0:
            return 1
        gray = cv2.cvtColor(crop, cv2.COLOR_BGR2GRAY)
        gray = cv2.resize(gray, None, fx=2.0, fy=2.0, interpolation=cv2.INTER_CUBIC)
        _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
        kernel = np.ones((3, 3), np.uint8)
        thresh = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel, iterations=1)
        config = "--psm 7 -c tessedit_char_whitelist=123"
        quantity = 1
        try:
            text_val = pytesseract.image_to_string(thresh, config=config)
        except Exception:
            text_val = ''
        import re
        match = re.search(r'[1-3]', text_val)
        if not match:
            thresh_inv = cv2.bitwise_not(thresh)
            try:
                text_val = pytesseract.image_to_string(thresh_inv, config=config)
            except Exception:
                text_val = ''
            match = re.search(r'[1-3]', text_val)
        if match:
            try:
                quantity = int(match.group(0))
            except Exception:
                quantity = 1
        return max(1, min(3, quantity))

    def click_n_times(self, button_key, count):
        count = max(1, min(3, int(count)))
        for i in range(count):
            button_name = self.button_aliases.get(button_key, button_key)
            self.select_button(button_name)
            if i != count - 1:
                time.sleep(0.05)

    def classify_special_item(self, image):
        if image is None or getattr(image, 'size', 0) == 0:
            return None
        hsv = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        mean_hsv = hsv.reshape(-1, 3).mean(axis=0)
        hue, sat, _ = mean_hsv
        if sat > 40:
            if 15 <= hue <= 40:
                return 'fries_icon'
            if 80 <= hue <= 140:
                return 'drinks_icon'
        return None

    def _mask_text_regions(self, image, aggressive=False):
        if image is None or getattr(image, 'size', 0) == 0:
            return image
        masked = image.copy()
        mean_color = tuple(int(c) for c in masked.reshape(-1, 3).mean(axis=0)) if masked.size else (0, 0, 0)
        try:
            gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
        except Exception:
            gray = cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)
        try:
            data = pytesseract.image_to_data(gray, output_type=pytesseract.Output.DICT)
        except Exception:
            data = None
        if data:
            n = len(data.get('text', []))
            for i in range(n):
                text_val = data['text'][i].strip() if data['text'][i] else ''
                conf_raw = data['conf'][i]
                conf = float(conf_raw) if conf_raw not in (None, '', '-1') else -1.0
                if text_val and conf >= 40:
                    x = int(data['left'][i])
                    y = int(data['top'][i])
                    w = int(data['width'][i])
                    h = int(data['height'][i])
                    x2 = min(x + w, image.shape[1])
                    y2 = min(y + h, image.shape[0])
                    cv2.rectangle(masked, (x, y), (x2, y2), mean_color, thickness=-1)
        if aggressive:
            top_h = int(masked.shape[0] * 0.32)
            if top_h > 0:
                lower_region = masked[top_h:, :] if top_h < masked.shape[0] else masked
                if lower_region.size > 0:
                    fill_color = tuple(int(c) for c in lower_region.reshape(-1, 3).mean(axis=0))
                else:
                    fill_color = mean_color
                masked[:top_h, :] = fill_color
                hsv = cv2.cvtColor(masked, cv2.COLOR_BGR2HSV)
                bright_text = cv2.inRange(hsv, (0, 0, 200), (180, 80, 255))
                masked[bright_text > 0] = fill_color
        return masked

    def _load_order_area(self):
        try:
            with open('bot_detection_area.json', 'r') as f:
                data = json.load(f)
            ratios = list(data.get('points_ratio', {}).values())
            if len(ratios) >= 2:
                xs = [r[0] for r in ratios if isinstance(r, (list, tuple)) and len(r) == 2]
                ys = [r[1] for r in ratios if isinstance(r, (list, tuple)) and len(r) == 2]
                if xs and ys:
                    return (max(0.0, min(xs)), max(0.0, min(ys)), min(1.0, max(xs)), min(1.0, max(ys)))
        except Exception:
            pass
        return None

    def _get_order_crop_bounds(self, width, height):
        if self.order_area:
            min_x_ratio, min_y_ratio, max_x_ratio, max_y_ratio = self.order_area
            x1 = int(width * min_x_ratio)
            x2 = int(width * max_x_ratio)
            y1 = int(height * min_y_ratio)
            y2 = int(height * max_y_ratio)
            x1 = max(0, min(x1, width - 1))
            x2 = max(x1 + 1, min(x2, width))
            y1 = max(0, min(y1, height - 1))
            y2 = max(y1 + 1, min(y2, height))
            return x1, x2, y1, y2
        x1 = int(width * (421/2560))
        x2 = int(width * (2116/2560))
        y1 = int(height * (232/1369))
        y2 = int(height * (545/1369))
        return x1, x2, y1, y2

    def _load_ui_profile(self):
        default_profile = {
            "ROI_BUBBLE": {"x": 0.165, "y": 0.17, "w": 0.67, "h": 0.23},
            "ROI_SIDES_GRID": {"x": 0.79, "y": 0.32, "w": 0.10, "h": 0.33},
            "ROI_SIZE_COL": {"x": 0.905, "y": 0.28, "w": 0.05, "h": 0.33},
            "ROI_CONFIRM": {"x": 0.965, "y": 0.58, "w": 0.03, "h": 0.08},
            "ROI_DRINKS_GRID": {"x": 0.79, "y": 0.32, "w": 0.10, "h": 0.33},
            "ROI_DRINK_TAB": {"x": 0.97, "y": 0.46, "w": 0.02, "h": 0.08},
        }
        try:
            with open("ui_profiles.json", "r") as f:
                profiles = json.load(f)
            if isinstance(profiles, dict):
                if "default" in profiles and isinstance(profiles["default"], dict):
                    profile = profiles["default"]
                else:
                    # pick the first profile dict found
                    profile = next((p for p in profiles.values() if isinstance(p, dict)), default_profile)
                merged = default_profile.copy()
                merged.update(profile or {})
                return merged
        except Exception:
            pass
        return default_profile

    def _rect_from_roi(self, roi, width, height):
        if not roi:
            return 0, width, 0, height
        x = roi.get("x", 0.0)
        y = roi.get("y", 0.0)
        w = roi.get("w", 1.0)
        h = roi.get("h", 1.0)
        x1 = int(width * x)
        y1 = int(height * y)
        x2 = int(width * (x + w))
        y2 = int(height * (y + h))
        x1 = max(0, min(x1, width - 1))
        y1 = max(0, min(y1, height - 1))
        x2 = max(x1 + 1, min(x2, width))
        y2 = max(y1 + 1, min(y2, height))
        return x1, x2, y1, y2

    def _extract_roi(self, image, roi):
        if image is None or getattr(image, "size", 0) == 0:
            return None
        height, width = image.shape[:2]
        x1, x2, y1, y2 = self._rect_from_roi(roi, width, height)
        return image[y1:y2, x1:x2]

    def _click_point(self, x, y):
        move_mouse(int(x), int(y))
        time.sleep(0.05)
        click_left(int(x), int(y), sleep_s=0.04)

    def _click_roi_center(self, roi, width, height):
        x1, x2, y1, y2 = self._rect_from_roi(roi, width, height)
        cx = (x1 + x2) // 2
        cy = (y1 + y2) // 2
        self._click_point(cx, cy)

    def _click_fries_type_cell(self, type_name, width, height):
        try:
            row_idx = self.fries_type_rows.index(type_name)
        except ValueError:
            row_idx = 0
        x1, x2, y1, y2 = self._rect_from_roi(self.roi_sides_grid, width, height)
        cell_height = (y2 - y1) / max(len(self.fries_type_rows), 1)
        target_x = (x1 + x2) / 2
        target_y = y1 + cell_height * (row_idx + 0.5)
        self._click_point(target_x, target_y)

    def _click_fries_size_option(self, size_label, width, height):
        size_index_map = {"S": 0, "M": 1, "L": 2}
        idx = size_index_map.get((size_label or "M").upper(), 1)
        x1, x2, y1, y2 = self._rect_from_roi(self.roi_size_col, width, height)
        cell_height = (y2 - y1) / 3.0
        target_x = (x1 + x2) / 2
        target_y = y1 + cell_height * (idx + 0.5)
        self._click_point(target_x, target_y)

    def _click_drink_type_cell(self, type_name, width, height):
        try:
            row_idx = self.drink_type_rows.index(type_name)
        except ValueError:
            row_idx = 0
        x1, x2, y1, y2 = self._rect_from_roi(self.roi_drinks_grid, width, height)
        cell_height = (y2 - y1) / max(len(self.drink_type_rows), 1)
        target_x = (x1 + x2) / 2
        target_y = y1 + cell_height * (row_idx + 0.5)
        self._click_point(target_x, target_y)

    def _click_drink_size_option(self, size_label, width, height):
        self._click_fries_size_option(size_label, width, height)

    def _are_size_buttons_visible(self, image: np.ndarray) -> bool:
        button_names = ['small', 'medium', 'large']
        visible = 0
        for name in button_names:
            coords = self._button_ratio_to_pixels(name)
            if not coords:
                continue
            x, y = coords
            sample = image[max(0, y - 10):min(image.shape[0], y + 10), max(0, x - 10):min(image.shape[1], x + 10)]
            if sample.size == 0:
                continue
            if float(np.std(sample)) > 5.0:
                visible += 1
        return visible >= 2

    def _ensure_fries_menu(self, image: np.ndarray, now: float) -> bool:
        if getattr(self, "phase2_menu_visible", False):
            return True
        if not getattr(self, "_phase2_nav_done", False):
            if now - getattr(self, "_phase2_nav_last_click", 0.0) >= 0.4:
                try:
                    self.select_button('fries_icon')
                    self._phase2_nav_done = True
                    self._phase2_nav_last_click = now
                    self.phase2_menu_deadline = now + 1.5
                except Exception:
                    self._phase2_nav_done = False
                    self._phase2_nav_last_click = now
                    self.phase2_menu_deadline = now + 0.5
            return False
        if self._are_size_buttons_visible(image):
            self.phase2_menu_visible = True
            return True
        if now >= getattr(self, "phase2_menu_deadline", 0.0):
            if not getattr(self, "phase2_menu_retry_used", False):
                self.phase2_menu_retry_used = True
                self._phase2_nav_done = False
                return False
            self.phase2_menu_visible = True
            return True
        return False

    def _ensure_drink_menu(self, image: np.ndarray, now: float) -> bool:
        if getattr(self, "_phase3_nav_done", False):
            return True
        height, width = image.shape[:2]
        if now - getattr(self, "_phase3_nav_last_click", 0.0) >= 0.5:
            try:
                if self.roi_drink_tab:
                    self._click_roi_center(self.roi_drink_tab, width, height)
                    time.sleep(0.15)
                self.select_button('drinks_icon')
                self._phase3_nav_done = True
            except Exception:
                self._phase3_nav_done = False
            self._phase3_nav_last_click = now
        if self._are_size_buttons_visible(image):
            self._phase3_nav_done = True
            return True
        return getattr(self, "_phase3_nav_done", False)


    def _load_phase2_templates(self):
        templates = {}
        try:
            base = 'images'
            for key, fname in {
                'fries': 'fries.png',
                'thick_fries': 'thick_fries.png',
                'onion_rings': 'onion_rings.png',
            }.items():
                path = os.path.join(base, fname)
                if os.path.exists(path):
                    img = cv2.imread(path)
                    if img is not None:
                        templates[key] = img
        except Exception:
            pass
        return templates

    def _load_phase2_size_templates(self):
        if self._phase2_size_templates is not None:
            return self._phase2_size_templates
        templates = {}
        try:
            base = os.path.join('images', 'phase 2', 'Fries Sizes')
            for label in ('S', 'M', 'L'):
                path = os.path.join(base, f"{label}.png")
                if os.path.exists(path):
                    img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)
                    if img is not None:
                        templates[label] = img
        except Exception:
            templates = {}
        self._phase2_size_templates = templates if templates else None
        return self._phase2_size_templates

    def _match_phase2_type(self, region_bgr, threshold=0.85):
        templates = getattr(self, '_phase2_templates', None)
        if templates is None:
            templates = self._load_phase2_templates()
            self._phase2_templates = templates
        if not templates or region_bgr is None or region_bgr.size == 0:
            return 'fries', 0.0
        best_name, best_score = 'fries', 0.0
        for name, tmpl in templates.items():
            try:
                scores = []
                for scale in (0.9, 1.0, 1.1):
                    th, tw = int(tmpl.shape[0] * scale), int(tmpl.shape[1] * scale)
                    if th < 2 or tw < 2:
                        continue
                    t = cv2.resize(tmpl, (tw, th), interpolation=cv2.INTER_AREA if scale < 1.0 else cv2.INTER_LINEAR)
                    if region_bgr.shape[0] < t.shape[0] or region_bgr.shape[1] < t.shape[1]:
                        continue
                    res = cv2.matchTemplate(region_bgr, t, cv2.TM_CCOEFF_NORMED)
                    if res.size:
                        scores.append(float(res.max()))
                score = max(scores) if scores else 0.0
                if score > best_score or (abs(score - best_score) <= 0.05 and name == 'fries'):
                    best_score, best_name = score, name
            except Exception:
                continue
        if best_score < threshold:
            return 'fries', best_score
        return best_name, best_score

    def _match_phase2_size_from_templates(self, order_bgr):
        templates = self._load_phase2_size_templates()
        if not templates or order_bgr is None or getattr(order_bgr, 'size', 0) == 0:
            return None, 0.0
        try:
            height = order_bgr.shape[0]
            if height <= 0:
                return None, 0.0
            region = order_bgr[int(height * 0.6):, :]
            if region.size == 0:
                return None, 0.0
            region_gray = cv2.cvtColor(region, cv2.COLOR_BGR2GRAY)
        except Exception:
            return None, 0.0
        best_label = None
        best_score = 0.0
        for label, tmpl in templates.items():
            if tmpl is None or tmpl.size == 0:
                continue
            th, tw = tmpl.shape[:2]
            rh, rw = region_gray.shape[:2]
            if rh < th or rw < tw:
                continue
            res = cv2.matchTemplate(region_gray, tmpl, cv2.TM_CCOEFF_NORMED)
            if res.size == 0:
                continue
            score = float(res.max())
            if score > best_score:
                best_score = score
                best_label = label
        if best_score >= 0.7:
            return best_label, best_score
        return None, best_score

    def _get_phase2_size(self, region_bgr):
        try:
            h = region_bgr.shape[0]
            crop = region_bgr[int(h*0.75):, :]
            gray = cv2.cvtColor(crop, cv2.COLOR_BGR2GRAY)
            gray = cv2.resize(gray, None, fx=2.0, fy=2.0, interpolation=cv2.INTER_CUBIC)
            _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            config = '--psm 7 -c tessedit_char_whitelist=SML'
            text_val = ''
            try:
                text_val = pytesseract.image_to_string(thresh, config=config)
            except Exception:
                text_val = ''
            import re as _re
            m = _re.search(r'[SML]', (text_val or '').upper())
            if not m:
                try:
                    inv = cv2.bitwise_not(thresh)
                    text_val = pytesseract.image_to_string(inv, config=config)
                    m = _re.search(r'[SML]', (text_val or '').upper())
                except Exception:
                    m = None
            size = (m.group(0) if m else 'M').upper()
            if size not in ('S','M','L'):
                size = 'M'
            return size
        except Exception:
            return 'M'

    def _plan_phase2_actions(self, masked_order, order_bgr, now: float):
        type_name, score = self._match_phase2_type(masked_order if masked_order is not None else order_bgr, threshold=0.85)
        template_size, template_score = self._match_phase2_size_from_templates(order_bgr)
        size_value = template_size if template_size is not None else self._get_phase2_size(masked_order if masked_order is not None else order_bgr)
        quantity_source = masked_order if masked_order is not None else order_bgr
        quantity_value = self.get_quantity_from_bottom(quantity_source)
        try:
            quantity_value = int(quantity_value)
        except Exception:
            quantity_value = 1
        valid_type = score >= 0.85
        valid_size = size_value in ('S', 'M', 'L')
        valid_quantity = 1 <= quantity_value <= 3
        if not valid_size and template_size is not None:
            size_value = template_size
            valid_size = True
        if not (valid_type and valid_size and valid_quantity):
            return None
        quantity_value = max(1, min(3, quantity_value))
        size_value = size_value if size_value in ('S', 'M', 'L') else 'M'
        actions = []
        target_type = type_name if type_name in ('fries', 'thick_fries', 'onion_rings') else 'fries'
        for _ in range(quantity_value):
            actions.append({'button': target_type, 'delay': 0.05})
        size_map = {'S': 'small', 'M': 'medium', 'L': 'large'}
        size_button = size_map.get(size_value, 'medium')
        actions.append({'button': size_button, 'delay': 0.08})
        return actions

    def handle_dialog(self, image: np.ndarray):
        match self.current_state:
            case 0:
                time.sleep(0.5)
                # Clear ingredients to identify section
                self.update_ingredients_to_identify([])
                if hasattr(self, 'phase2_info_label'):
                    self.phase2_info_label.config(text="Sides: waiting")
                if hasattr(self, 'phase3_info_label'):
                    self.phase3_info_label.config(text="Drinks: waiting")
                self._phase2_attempt_started = None
                self._phase3_attempt_started = None
                self._phase2_nav_done = False
                self._phase3_nav_done = False
                self.phase2_menu_visible = False
                self.phase2_menu_retry_used = False
                self._phase2_nav_last_click = 0.0
                self._phase3_nav_last_click = 0.0
                return
            case 1:
                if not self.order_started:
                    self.order_started = True
                    self._phase2_attempt_started = None
                    self._phase3_attempt_started = None
                    self._phase2_nav_done = False
                    self._phase3_nav_done = False
                    self.phase2_menu_visible = False
                    self.phase2_menu_retry_used = False
                height, width = image.shape[:2]
                try:
                    x1, x2, y1, y2 = self._get_order_crop_bounds(width, height)
                except Exception:
                    x1_prop = 421/2560
                    x2_prop = 2116/2560
                    y1_prop = 232/1369
                    y2_prop = 545/1369
                    x1 = int(width * x1_prop)
                    x2 = int(width * x2_prop)
                    y1 = int(height * y1_prop)
                    y2 = int(height * y2_prop)
                relevant_portion_rgb = image[y1:y2, x1:x2]
                if relevant_portion_rgb.size == 0:
                    self.update_ingredients_to_identify([])
                    return
                relevant_portion_bgr = cv2.cvtColor(relevant_portion_rgb, cv2.COLOR_RGB2BGR)

                for item in self.items:
                    self.items_in_order[item] = 0
                for key in self.extra_items:
                    self.extra_items[key] = 0

                all_items_bgr = split_order_items(relevant_portion_bgr)
                counts_map, detection_crops = parse_ingredient_order(relevant_portion_bgr)
                counts_map = counts_map or {}
                detection_crops = detection_crops or []

                if detection_crops:
                    display_items = [Image.fromarray(cv2.cvtColor(section, cv2.COLOR_BGR2RGB)) for section in detection_crops]
                else:
                    display_items = [Image.fromarray(cv2.cvtColor(section, cv2.COLOR_BGR2RGB)) for section in all_items_bgr]

                parsed_total = sum(max(0, counts_map.get(item, 0)) for item in self.items)
                print(f"ingredient detections (parsed_total={parsed_total}): {len(detection_crops) if detection_crops else len(all_items_bgr)}")
                ingredients_added = False

                for item in self.items:
                    qty = max(0, counts_map.get(item, 0))
                    self.items_in_order[item] = qty
                    if qty > 0:
                        ingredients_added = True

                if not ingredients_added:
                    for section_bgr in all_items_bgr:
                        if section_bgr is None or section_bgr.size == 0:
                            continue
                        clean_section = self._mask_text_regions(section_bgr, aggressive=True)
                        item_idx = identify_ingredient(clean_section)
                        if 0 <= item_idx < len(self.items):
                            quantity = self.get_quantity_from_bottom(section_bgr)
                            ingredient_name = self.items[item_idx]
                            self.items_in_order[ingredient_name] += quantity
                            ingredients_added = True

                for section_bgr in all_items_bgr:
                    if section_bgr is None or section_bgr.size == 0:
                        continue
                    clean_section = self._mask_text_regions(section_bgr, aggressive=True)
                    special = self.classify_special_item(clean_section)
                    if special and special in self.extra_items:
                        quantity = self.get_quantity_from_bottom(section_bgr)
                        self.extra_items[special] += quantity
                        ingredients_added = True

                self.update_gui_ingredients()
                self.update_ingredients_to_identify(display_items)

                if not ingredients_added:
                    if (time.time() - self._last_repeat_request) >= 4.0:
                        self.select_button("can_you_repeat")
                        self._last_repeat_request = time.time()
                    return

                self.select_button("bottom_bun")
                time.sleep(0.4)
                for item, count in self.items_in_order.items():
                    if count > 0:
                        print(f"clicking on {item} x{count}")
                        self.click_n_times(item, count)
                        time.sleep(0.4)
                for extra_key, count in self.extra_items.items():
                    if count > 0:
                        print(f"clicking on {extra_key} x{count}")
                        self.click_n_times(extra_key, count)
                        time.sleep(0.4)
                self.select_button("top_bun")
                time.sleep(0.4)

                return
            case 2:
                bubble_rgb = self._extract_roi(image, self.roi_bubble)
                display_items = []
                if bubble_rgb is not None and getattr(bubble_rgb, 'size', 0) > 0:
                    display_items = [Image.fromarray(bubble_rgb)]
                self.update_ingredients_to_identify(display_items)

                if not self.order_started:
                    if (time.time() - self._last_repeat_request) >= 4.0:
                        self.select_button("can_you_repeat")
                        self._last_repeat_request = time.time()
                    return

                if self._phase2_attempt_started is None:
                    self._phase2_attempt_started = time.time()

                detection = detect_fries_request(bubble_rgb)
                type_label = detection.get('type')
                size_label = detection.get('size')
                type_conf = detection.get('conf', 0.0)
                size_conf = detection.get('size_conf', 0.0)
                quantity = detection.get('quantity', 1) or 1
                quantity = min(3, max(0, int(quantity)))

                next_action = 'retry'
                if type_label == 'none':
                    next_action = 'confirm'
                elif type_label and type_conf >= self.type_conf_threshold and (size_label and size_conf >= self.size_conf_threshold):
                    next_action = 'type->size->confirm'

                info_text = (
                    f"Sides: type={type_label or '?'} ({type_conf:.2f}) "
                    f"size={size_label or '?'} ({size_conf:.2f}) qty={quantity} next={next_action}"
                )
                self.phase2_info_label.config(text=info_text)

                width = image.shape[1]
                height = image.shape[0]
                self._debug_last_phase2_masked = self._extract_roi(image, self.roi_sides_grid)

                now_ts = time.time()
                if type_label == 'none':
                    self.phase2_info_label.config(text="Sides: none -> confirm")
                    self._click_roi_center(self.roi_confirm, width, height)
                    self._phase2_attempt_started = None
                    self.phase2_menu_visible = False
                    self._phase2_nav_done = False
                    return

                conf_ok = bool(type_label) and type_conf >= self.type_conf_threshold
                size_ok = bool(size_label) and size_conf >= self.size_conf_threshold

                if not (conf_ok and size_ok):
                    if self._phase2_attempt_started and (now_ts - self._phase2_attempt_started) > 1.3:
                        if (now_ts - self._last_repeat_request) >= 1.0:
                            self.select_button("can_you_repeat")
                            self._last_repeat_request = now_ts
                        self._phase2_attempt_started = None
                    return

                if not self._ensure_fries_menu(image, now_ts):
                    return
                try:
                    self.select_button("fries_icon")
                    time.sleep(0.25)
                except Exception:
                    pass

                clicks_needed = max(1, quantity)
                for _ in range(clicks_needed):
                    self._click_fries_type_cell(type_label, width, height)
                    time.sleep(0.18)
                self._click_fries_size_option(size_label or 'M', width, height)
                time.sleep(0.2)
                self._click_roi_center(self.roi_confirm, width, height)
                self.phase2_info_label.config(text=f"Sides: {type_label} ({size_label or '?'}) confirmed")
                self._phase2_attempt_started = None
                self.phase2_menu_visible = False
                self._phase2_nav_done = False
                return
            case 3:
                bubble_rgb = self._extract_roi(image, self.roi_bubble)
                display_items = []
                if bubble_rgb is not None and getattr(bubble_rgb, "size", 0) > 0:
                    display_items = [Image.fromarray(bubble_rgb)]
                self.update_ingredients_to_identify(display_items)

                if not self.order_started:
                    if (time.time() - self._last_repeat_request) >= 4.0:
                        self.select_button("can_you_repeat")
                        self._last_repeat_request = time.time()
                    return

                if self._phase3_attempt_started is None:
                    self._phase3_attempt_started = time.time()

                detection = detect_drink_request(bubble_rgb)
                type_label = detection.get('type')
                size_label = detection.get('size')
                type_conf = detection.get('conf', 0.0)
                size_conf = detection.get('size_conf', 0.0)
                quantity = detection.get('quantity', 1) or 1
                quantity = min(3, max(0, int(quantity)))

                next_action = 'retry'
                if type_label == 'none':
                    next_action = 'confirm'
                elif type_label and type_conf >= self.type_conf_threshold and (size_label and size_conf >= self.size_conf_threshold):
                    next_action = 'type->size->confirm'

                info_text = (
                    f"Drinks: type={type_label or '?'} ({type_conf:.2f}) "
                    f"size={size_label or '?'} ({size_conf:.2f}) next={next_action}"
                )
                self.phase3_info_label.config(text=info_text)

                width = image.shape[1]
                height = image.shape[0]
                now_ts = time.time()

                if type_label == 'none':
                    self._click_roi_center(self.roi_confirm, width, height)
                    self.phase3_info_label.config(text="Drinks: none -> confirm")
                    self._phase3_attempt_started = None
                    self._phase3_nav_done = False
                    return

                conf_ok = bool(type_label) and type_conf >= self.type_conf_threshold
                size_ok = bool(size_label) and size_conf >= self.size_conf_threshold

                if not (conf_ok and size_ok):
                    if self._phase3_attempt_started and (now_ts - self._phase3_attempt_started) > 1.3:
                        if (now_ts - self._last_repeat_request) >= 1.0:
                            self.select_button("can_you_repeat")
                            self._last_repeat_request = now_ts
                        self._phase3_attempt_started = None
                        self._phase3_nav_done = False
                    return

                if not self._ensure_drink_menu(image, now_ts):
                    return

                try:
                    self.select_button("drinks_icon")
                    time.sleep(0.25)
                except Exception:
                    pass

                self._click_drink_type_cell(type_label, width, height)
                time.sleep(0.18)
                self._click_drink_size_option(size_label or 'M', width, height)
                time.sleep(0.2)
                self._click_roi_center(self.roi_confirm, width, height)
                self.phase3_info_label.config(text=f"Drinks: {type_label} ({size_label or '?'}) confirmed")
                self._phase3_attempt_started = None
                self._phase3_nav_done = False
                return
            case 4:
                self.update_ingredients_to_identify([])  # Clear section
                if hasattr(self, 'phase2_info_label'):
                    self.phase2_info_label.config(text="Sides: waiting")
                if hasattr(self, 'phase3_info_label'):
                    self.phase3_info_label.config(text="Drinks: waiting")
                if not self.order_started:
                    self.select_button("can_you_repeat")
                else:
                    self.order_started = False
                    self.update_gui_ingredients()  # Clear ingredients when order ends
                    time.sleep(1)
                self._phase2_attempt_started = None
                self._phase3_attempt_started = None
                self._phase2_nav_done = False
                self._phase3_nav_done = False
                self.phase2_menu_visible = False
                self.phase2_menu_retry_used = False
                self._phase2_nav_last_click = 0.0
                self._phase3_nav_last_click = 0.0
                return
                
    def loop(self):
        target_interval = getattr(self, 'target_frame_interval', 1.0 / 60.0)
        while self.running:
            frame_start = time.perf_counter()
            try:
                self.screen_width, self.screen_height = get_screen_size()
                screenshot = capture_screen()
                print("new screenshot")
                image_rgb = np.array(screenshot)
                image_bgr = cv2.cvtColor(image_rgb, cv2.COLOR_RGB2BGR)

                # Always update GUI screenshot
                display_image = Image.fromarray(image_rgb)
                self._update_fps_meter(self._display_frame_times, 'display')
                self.update_gui_screenshot(display_image)

                new_state = get_current_phase(image_rgb)
                self._update_fps_meter(self._capture_frame_times, 'capture')
                print("Here's the new state", new_state)
                self.current_state = new_state
                self.update_gui_state()
                self.handle_dialog(image_rgb)
            except KeyboardInterrupt:
                self.running = False
                break
            except Exception as e:
                print(f"Error in main loop: {e}")
            finally:
                elapsed = time.perf_counter() - frame_start
                sleep_time = max(0.0, target_interval - elapsed)
                if self.running and sleep_time > 0:
                    time.sleep(sleep_time)

    def select_button(self, ingredient_name: str):
        """
        Move mouse to ingredient button and click it.

        Args:
            ingredient_name: Name of ingredient (e.g. 'lettuce', 'patty')
        """
        ingredient_name = self.button_aliases.get(ingredient_name, ingredient_name)
        try:
            # Load button coordinates from JSON file
            with open('bot_params.json', 'r') as f:
                params = json.load(f)

            if ingredient_name not in params['button_coords']:
                print(f"Warning: {ingredient_name} not found in bot_params.json")
                return

            # Get target coordinates as fractions
            target_fraction = params['button_coords'][ingredient_name]

            # Convert to actual screen coordinates
            target_x = int(target_fraction[0] * self.screen_width)
            target_y = int(target_fraction[1] * self.screen_height)

            # Get current mouse position
            current_x, current_y = get_cursor_pos()

            # Calculate distance and number of steps for smooth movement
            distance = math.sqrt((target_x - current_x)**2 + (target_y - current_y)**2)
            steps = max(int(distance * 0.06), 20)  # More intermediate points for smoother motion
            step_sleep = max(self.step_duraction_alpha, 0.01)

            # Generate curved path using a bezier-like curve
            for i in range(steps + 1):
                t = i / steps

                # Add curve by introducing a control point offset
                mid_x = (current_x + target_x) / 2
                mid_y = (current_y + target_y) / 2

                # Add some randomness and curve to the path
                curve_offset_x = math.sin(t * math.pi) * 20 * (1 if target_x > current_x else -1)
                curve_offset_y = math.sin(t * math.pi) * 15 * (1 if target_y > current_y else -1)

                # Quadratic bezier curve calculation
                x = (1-t)**2 * current_x + 2*(1-t)*t * (mid_x + curve_offset_x) + t**2 * target_x
                y = (1-t)**2 * current_y + 2*(1-t)*t * (mid_y + curve_offset_y) + t**2 * target_y

                # Move mouse to calculated position
                move_mouse(int(x), int(y))
                time.sleep(step_sleep)

            # Ensure cursor settles on target before clicking
            for _ in range(6):
                time.sleep(0.01)
                cur_x, cur_y = get_cursor_pos()
                if abs(cur_x - target_x) <= 2 and abs(cur_y - target_y) <= 2:
                    break
                move_mouse(target_x, target_y)

            time.sleep(0.02)
            click_left(target_x, target_y, sleep_s=0.04)
            print(f"Selected {ingredient_name} at ({target_x}, {target_y})")

        except FileNotFoundError:
            print("Error: bot_params.json file not found")
        except json.JSONDecodeError:
            print("Error: Invalid JSON in bot_params.json")
        except Exception as e:
            print(f"Error selecting ingredient {ingredient_name}: {e}")

def signal_handler(signum, frame):
    """Handle Ctrl+C signal"""
    print("\nReceived interrupt signal. Shutting down...")
    if 'bot' in globals():
        bot.shutdown()
    sys.exit(0)

if __name__ == "__main__":
    # Set up signal handler for Ctrl+C
    signal.signal(signal.SIGINT, signal_handler)
    
    bot = FastFoodBot()
    
    try:
        # Start the bot logic in a background thread
        bot_thread = threading.Thread(target=bot.loop, daemon=True)
        bot_thread.start()
        
        # Run the GUI in the main thread
        bot.gui_root.mainloop()
    except KeyboardInterrupt:
        bot.shutdown()
    finally:
        print("Program terminated.")
